*********************************************************************************
| hey! I have developed an efficient pseudorandom function, PRF, but it needs   |
| deep tests for security points!! Try hard to break this PRF and get the flag! |
| In each step I will compute the f_a(n), f_a(n + 1), f_a(n + 2), f_a(n+3), and |
| f_a(n + 4) for secret verctor a, and for your given positive number 0 < n < p |
*********************************************************************************
| for n = 98199951302215711051429358164423948855, and with these PRF parameters: 
| (p, g) = (0xa5b80863b39a3e96d977c8643c4aee27, 0x1569cdd327ca024e697126a916e6c680) 
| the five consecutive random numbers generated by our secure PRF are: 
| f_a(n + 0) = 32018926747880781870818419149123000486
| f_a(n + 1) = 220112245704810102801448451172786975350
| f_a(n + 2) = 93961603864995523879506774294783742735
| f_a(n + 3) = 30216000626561977313049343150984758011
| f_a(n + 4) = 22759142941409636545517699182836380570 
| Options: 
|	[G]uess next number! 
|	[P]RF function 
|	[N]ew numbers
|	[Q]uit
P
def gg(tup, a, x):
	(_, p, g), n = tup, len(a)
	assert len(bin(x)[2:]) <= n
	X = bin(x)[2:].zfill(n)
	f_ax = g
	for i in range(1, n):
		f_ax *= pow(g, a[i] * int(X[i]), p)
	return f_ax % p
